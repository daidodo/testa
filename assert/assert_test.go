package assert

import (
	"testing"
	"unsafe"
)

func TestIsNil(t *testing.T) {
	True(t, isNil(nil))
	False(t, isNil(true))
	False(t, isNil(false))
	False(t, isNil(int(0)))
	False(t, isNil(int(100)))
	False(t, isNil(Int(0)))
	False(t, isNil(Int(100)))
	False(t, isNil(int8(0)))
	False(t, isNil(int8(100)))
	False(t, isNil(int16(0)))
	False(t, isNil(int16(100)))
	False(t, isNil(int32(0)))
	False(t, isNil(int32(100)))
	False(t, isNil(int64(0)))
	False(t, isNil(int64(100)))
	False(t, isNil(uint(0)))
	False(t, isNil(uint(100)))
	False(t, isNil(Uint(0)))
	False(t, isNil(Uint(100)))
	False(t, isNil(uint8(0)))
	False(t, isNil(uint8(100)))
	False(t, isNil(uint16(0)))
	False(t, isNil(uint16(100)))
	False(t, isNil(uint32(0)))
	False(t, isNil(uint32(100)))
	False(t, isNil(uint64(0)))
	False(t, isNil(uint64(100)))
	False(t, isNil(uintptr(0)))
	False(t, isNil(uintptr(100)))
	False(t, isNil(Uintptr(0)))
	False(t, isNil(Uintptr(100)))
	False(t, isNil(float32(0)))
	False(t, isNil(float32(100)))
	False(t, isNil(float64(0)))
	False(t, isNil(float64(100)))
	False(t, isNil(Float(0)))
	False(t, isNil(Float(100)))
	False(t, isNil(complex64(0)))
	False(t, isNil(complex64(100)))
	False(t, isNil(complex128(0)))
	False(t, isNil(complex128(100)))
	False(t, isNil(Complex(0)))
	False(t, isNil(Complex(100)))
	False(t, isNil(string("")))
	False(t, isNil(string("abc")))
	False(t, isNil(Str("")))
	False(t, isNil(Str("abc")))
	True(t, isNil(chan int(nil)))
	False(t, isNil(make(chan int)))
	True(t, isNil(Chan(nil)))
	False(t, isNil(make(Chan)))
	True(t, isNil((func(int) bool)(nil)))
	False(t, isNil(func(int) bool { return false }))
	True(t, isNil(Func(nil)))
	False(t, isNil(Func(func(int) bool { return false })))
	True(t, isNil((*bool)(nil)))
	False(t, isNil(new(bool)))
	True(t, isNil(Ptr(nil)))
	False(t, isNil(Ptr(new(int))))
	True(t, isNil(unsafe.Pointer(nil)))
	False(t, isNil(unsafe.Pointer(new(int))))
	True(t, isNil(UPtr(nil)))
	False(t, isNil(UPtr(new(int))))
	True(t, isNil(A{}.a))
	True(t, isNil(A{}.b))
	False(t, isNil(A{a: 100}.a))
	False(t, isNil(A{b: A{}}.b))
	False(t, isNil([...]int{}))
	False(t, isNil([...]int{1, 2, 3}))
	False(t, isNil(Array{}))
	True(t, isNil([]int(nil)))
	False(t, isNil([]int{}))
	False(t, isNil([]int{1, 2, 3}))
	True(t, isNil(Slice(nil)))
	False(t, isNil(Slice{}))
	False(t, isNil(Slice{1, 2, 3}))
	True(t, isNil(map[bool]int(nil)))
	False(t, isNil(map[bool]int{}))
	False(t, isNil(map[bool]int{true: 100}))
	True(t, isNil(Map(nil)))
	False(t, isNil(Map{}))
	False(t, isNil(Map{true: 100}))
	False(t, isNil(A{}))
	False(t, isNil(Struct{}))
}

func TestIsSameInValue(t *testing.T) {
	cs := []interface{}{
		nil, true, false,
		int8(-0x80), int8(0), int8(0x7F), int8(-1),
		int16(-0x8000), int16(-0x80), int16(0), int16(0x7F), int16(0x7FFF), int16(-1),
		int32(-0x80000000), int32(-0x8000), int32(-0x80), int32(0), int32(0x7F), int32(0x7FFF), int32(0x7FFFFFFF), int32(-1),
		int64(-0x8000000000000000), int64(-0x80000000), int64(-0x8000), int64(-0x80), int64(0), int64(0x7F), int64(0x7FFF), int64(0x7FFFFFFF), int64(0x7FFFFFFFFFFFFFFF), int64(-1),
		int(-0x8000000000000000), int(-0x80000000), int(-0x8000), int(-0x80), int(0), int(0x7F), int(0x7FFF), int(0x7FFFFFFF), int(0x7FFFFFFFFFFFFFFF), int(-1),
		uint8(0), uint8(0x7F), uint(0x80), uint8(0xFF),
		uint16(0), uint16(0x7FFF), uint16(0x8000), uint16(0xFFFF),
		uint32(0), uint32(0x7FFFFFFF), uint32(0x80000000), uint32(0xFFFFFFFF),
		uint64(0), uint64(0x7FFFFFFFFFFFFFFF), uint64(0x8000000000000000), uint64(0xFFFFFFFFFFFFFFFF),
		uint(0), uint(0x7FFFFFFFFFFFFFFF), uint(0x8000000000000000), uint(0xFFFFFFFFFFFFFFFF),
		uintptr(0), uintptr(0x7FFFFFFFFFFFFFFF), uintptr(0x8000000000000000), uintptr(0xFFFFFFFFFFFFFFFF),
		float32(-0x8000000000000000), float32(-0x80000000), float32(-0x8000), float32(-0x80), float32(0), float32(0x7F), float32(0x7FFF), float32(0x80), float32(0x8000), float32(0xFF), float32(0xFFFF),
		float64(-0x8000000000000000), float64(-0x80000000), float64(-0x8000), float64(-0x80), float64(0), float64(0x7F), float64(0x7FFF), float64(0x7FFFFFFF), float64(0x80), float64(0x8000), float64(0x80000000), float64(0xFF), float64(0xFFFF), float64(0xFFFFFFFF),
		complex64(0), complex64(0x7F), complex64(0 + 0.25i), complex64(0x7F + 0.25i),
		complex128(0), complex128(0x7F), complex128(0 + 0.25i), complex128(0x7F + 0.25i),
		[0]int{}, [...]int{1, 2, 3}, [...]uint{1, 2, 3},
	}
	rs := []string{
		"", "", "",
		"000", "000", "000", "000", // int8
		"000 0000", "000 1000", "000 0100", "000 0010", "000 0000", "000 0001", // int16
		// int32
		"000 0000 000000",
		"000 0000 100000",
		"000 1000 010000",
		"000 0100 001000",
		"000 0010 000100",
		"000 0000 000010",
		"000 0000 000000",
		"000 0001 000001",
		// int64
		"000 0000 000000 00000000",
		"000 0000 000000 10000000",
		"000 0000 100000 01000000",
		"000 1000 010000 00100000",
		"000 0100 001000 00010000",
		"000 0010 000100 00001000",
		"000 0000 000010 00000100",
		"000 0000 000000 00000010",
		"000 0000 000000 00000000",
		"000 0001 000001 00000001",
		// int
		"000 0000 000000 00000000 1000000000",
		"000 0000 000000 10000000 0100000000",
		"000 0000 100000 01000000 0010000000",
		"000 1000 010000 00100000 0001000000",
		"000 0100 001000 00010000 0000100000",
		"000 0010 000100 00001000 0000010000",
		"000 0000 000010 00000100 0000001000",
		"000 0000 000000 00000010 0000000100",
		"000 0000 000000 00000000 0000000010",
		"000 0001 000001 00000001 0000000001",
		// uint8
		"000 0100 001000 00010000 0000100000 0000100000",
		"000 0010 000100 00001000 0000010000 0000010000",
		"000 0000 000000 00000000 0000000000 0000000000",
		"000 0000 000000 00000000 0000000000 0000000000",
		// uint16
		"000 0100 001000 00010000 0000100000 0000100000 1000",
		"000 0000 000010 00000100 0000001000 0000001000 0000",
		"000 0000 000000 00000000 0000000000 0000000000 0000",
		"000 0000 000000 00000000 0000000000 0000000000 0000",
		// uint32
		"000 0100 001000 00010000 0000100000 0000100000 1000 1000",
		"000 0000 000000 00000010 0000000100 0000000100 0000 0000",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0000",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0000",
		// uint64
		"000 0100 001000 00010000 0000100000 0000100000 1000 1000 1000",
		"000 0000 000000 00000000 0000000010 0000000010 0000 0000 0000",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0000 0000",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0000 0000",
		// uint
		"000 0100 001000 00010000 0000100000 0000100000 1000 1000 1000 1000",
		"000 0000 000000 00000000 0000000010 0000000010 0000 0000 0000 0100",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0000 0000 0010",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0000 0000 0001",
		// uintptr
		"000 0100 001000 00010000 0000100000 0000100000 1000 1000 1000 1000 1000",
		"000 0000 000000 00000000 0000000010 0000000010 0000 0000 0000 0100 0100",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0000 0000 0010 0010",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0000 0000 0001 0001",
		// float32
		"000 0000 000000 00000000 1000000000 1000000000 0000 0000 0000 0000 0000 0000",
		"000 0000 000000 10000000 0100000000 0100000000 0000 0000 0000 0000 0000 0000",
		"000 0000 100000 01000000 0010000000 0010000000 0000 0000 0000 0000 0000 0000",
		"000 1000 010000 00100000 0001000000 0001000000 0000 0000 0000 0000 0000 0000",
		"000 0100 001000 00010000 0000100000 0000100000 1000 1000 1000 1000 1000 1000",
		"000 0010 000100 00001000 0000010000 0000010000 0100 0000 0000 0000 0000 0000",
		"000 0000 000010 00000100 0000001000 0000001000 0000 0100 0000 0000 0000 0000",
		"000 0000 000000 00000000 0000000000 0000000000 0010 0000 0000 0000 0000 0000",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0010 0000 0000 0000 0000",
		"000 0000 000000 00000000 0000000000 0000000000 0001 0000 0000 0000 0000 0000",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0001 0000 0000 0000 0000",
		// float64
		"000 0000 000000 00000000 1000000000 1000000000 0000 0000 0000 0000 0000 0000 10000000000",
		"000 0000 000000 10000000 0100000000 0100000000 0000 0000 0000 0000 0000 0000 01000000000",
		"000 0000 100000 01000000 0010000000 0010000000 0000 0000 0000 0000 0000 0000 00100000000",
		"000 1000 010000 00100000 0001000000 0001000000 0000 0000 0000 0000 0000 0000 00010000000",
		"000 0100 001000 00010000 0000100000 0000100000 1000 1000 1000 1000 1000 1000 00001000000",
		"000 0010 000100 00001000 0000010000 0000010000 0100 0000 0000 0000 0000 0000 00000100000",
		"000 0000 000010 00000100 0000001000 0000001000 0000 0100 0000 0000 0000 0000 00000010000",
		"000 0000 000000 00000010 0000000100 0000000100 0000 0000 0100 0000 0000 0000 00000000000",
		"000 0000 000000 00000000 0000000000 0000000000 0010 0000 0000 0000 0000 0000 00000001000",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0010 0000 0000 0000 0000 00000000100",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0000 0010 0000 0000 0000 00000000000",
		"000 0000 000000 00000000 0000000000 0000000000 0001 0000 0000 0000 0000 0000 00000000010",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0001 0000 0000 0000 0000 00000000001",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0000 0001 0000 0000 0000 00000000000",
		// complex64
		"000 0100 001000 00010000 0000100000 0000100000 1000 1000 1000 1000 1000 1000 00001000000 00001000000000",
		"000 0010 000100 00001000 0000010000 0000010000 0100 0000 0000 0000 0000 0000 00000100000 00000100000000",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0000 0000 0000 0000 0000 00000000000 00000000000000",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0000 0000 0000 0000 0000 00000000000 00000000000000",
		// complex128
		"000 0100 001000 00010000 0000100000 0000100000 1000 1000 1000 1000 1000 1000 00001000000 00001000000000 1000",
		"000 0010 000100 00001000 0000010000 0000010000 0100 0000 0000 0000 0000 0000 00000100000 00000100000000 0100",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0000 0000 0000 0000 0000 00000000000 00000000000000 0010",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0000 0000 0000 0000 0000 00000000000 00000000000000 0001",
		// array
		"000 0000 000000 00000000 0000000000 0000000000 0000 0000 0000 0000 0000 0000 00000000000 00000000000000 0000 0000",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0000 0000 0000 0000 0000 00000000000 00000000000000 0000 0000",
		"000 0000 000000 00000000 0000000000 0000000000 0000 0000 0000 0000 0000 0000 00000000000 00000000000000 0000 0000 010",
	}
	for i := 0; i < len(cs); i++ {
		e, ri, id := cs[i], rs[i], -1
		rr := func() bool {
			id++
			for id < len(ri) && ri[id] == ' ' {
				id++
			}
			return id < len(ri) && ri[id] == '1'
		}
		for j := 0; j <= i; j++ {
			r := rr() || i == j
			a := cs[j]
			Equal(t, r, isSameInValue(e, a), "i=%v, j=%v\n%T\t%[3]v\n%T\t%[4]v", i, j, e, a)
			Equal(t, r, isSameInValue(a, e), "i=%v, j=%v\n%T\t%[3]v\n%T\t%[4]v", i, j, e, a)
		}
	}

	//t1 := func(a interface{}, r string) {
	//    i := 0
	//    rr := func() (b bool) {
	//        if i < len(r) {
	//            if r[i] == ' ' {
	//                i++
	//            }
	//            b = r[i] == '1'
	//        }
	//        i++
	//        return
	//    }
	//    tt(a, nil, rr())
	//    tt(a, true, rr())
	//    tt(a, false, rr())

	//    tt(a, int8(-100), rr())
	//    tt(a, int8(0), rr())
	//    tt(a, int8(100), rr())

	//    tt(a, int16(-10000), rr())
	//    tt(a, int16(-100), rr())
	//    tt(a, int16(0), rr())
	//    tt(a, int16(100), rr())
	//    tt(a, int16(10000), rr())

	//    tt(a, int32(-10000), rr())
	//    tt(a, int32(-10000), rr())
	//    tt(a, int32(-100), rr())
	//    tt(a, int32(0), rr())
	//    tt(a, int32(100), rr())
	//    tt(a, int32(10000), rr())

	//    tt(a, int(100), rr())
	//    tt(a, uint(100), rr())

	//    tt(a, uintptr(100), rr())
	//    tt(a, string("100"), rr())
	//    tt(a, chan int(nil), rr())
	//    tt(a, make(chan int), rr())

	//    tt(a, (func(bool) int)(nil), rr())
	//    tt(a, func(bool) int { return 0 }, rr())
	//    tt(a, (*int)(nil), rr())
	//    tt(a, new(int), rr())

	//    tt(a, unsafe.Pointer(nil), rr())
	//    tt(a, unsafe.Pointer(new(int)), rr())
	//    tt(a, [0]int{}, rr())
	//    tt(a, [...]int{1, 2, 3}, rr())

	//    tt(a, []int(nil), rr())
	//    tt(a, []int{}, rr())
	//    tt(a, []int{1, 2, 3}, rr())
	//    tt(a, map[bool]int(nil), rr())

	//    tt(a, map[bool]int{}, rr())
	//    tt(a, map[bool]int{true: 10}, rr())
	//    tt(a, A{}, rr())
	//}
	//t1(nil, "1000 0010 1010 1000 1001 000")
}
