package assert

import (
	"reflect"
	"testing"
	"unsafe"
)

func TestConvertible(t *testing.T) {
	cs := []interface{}{
		nil, true,
		int8(1), int16(1), int32(1), int64(1), int(1),
		uint8(1), uint16(1), uint32(1), uint64(1), uint(1), uintptr(1),
		float32(1), float64(1),
		complex64(1), complex128(1),
		new(int), new(uint), unsafe.Pointer(nil),
		make(chan int), make(chan uint), func(int) bool { return true },
		string("abc"),
		[...]int{1, 2, 3}, [...]float32{1, 2, 3}, [...]byte{1, 2, 3}, [...]rune{1, 2, 3}, [...]interface{}{1, 2, 3}, [...]I{nil},
		[]int{1, 2, 3}, []float32{1, 2, 3}, []byte{1, 2, 3}, []rune{1, 2, 3}, []interface{}{1, 2, 3}, []I{nil},
		map[int]uint{}, map[uint]bool{}, map[bool]float32{}, map[bool]bool{}, map[uint]float32{}, map[interface{}]bool{}, map[bool]interface{}{}, map[interface{}]interface{}{},
		A{}, B{},
	}
	rs := []string{
		"", "",
		"00 11111", "00 11111", "00 11111", "00 11111", "00 11111",
		"00 11111 111111", "00 11111 111111", "00 11111 111111", "00 11111 111111", "00 11111 111111", "00 11111 111111",
		"00 11111 111111 11", "00 11111 111111 11",
		"00 11111 111111 11 11", "00 11111 111111 11 11",
		"00 00000 000000 00 00 101", "00 00000 000000 00 00 011", "00 00000 000000 00 00 111",
		"00 00000 000000 00 00 000", "00 00000 000000 00 00 000", "00 00000 000000 00 00 000",
		"00 11111 111111 00 00 000 000",
		// array
		"00 00000 000000 00 00 000 000 0",
		"00 00000 000000 00 00 000 000 0 1",
		"00 00000 000000 00 00 000 000 1 11",
		"00 00000 000000 00 00 000 000 1 111",
		"00 00000 000000 00 00 000 000 0 1111",
		"00 00000 000000 00 00 000 000 0 00001",
		// slice
		"00 00000 000000 00 00 000 000 0 111110",
		"00 00000 000000 00 00 000 000 0 111110 1",
		"00 00000 000000 00 00 000 000 1 111110 11",
		"00 00000 000000 00 00 000 000 1 111110 111",
		"00 00000 000000 00 00 000 000 0 111111 1111",
		"00 00000 000000 00 00 000 000 0 000011 00001",
		// map
		"00 00000 000000 00 00 000 000 0 000000 000000",
		"00 00000 000000 00 00 000 000 0 000000 000000",
		"00 00000 000000 00 00 000 000 0 000000 000000",
		"00 00000 000000 00 00 000 000 0 000000 000000",
		"00 00000 000000 00 00 000 000 0 000000 000000 1",
		"00 00000 000000 00 00 000 000 0 000000 000000 0101",
		"00 00000 000000 00 00 000 000 0 000000 000000 001101",
		"00 00000 000000 00 00 000 000 0 000000 000000 1111111",
		// struct
		"00 00000 000000 00 00 000 000 0 000000 000000 00000000",
		"00 00000 000000 00 00 000 000 0 000000 000000 00000000",
	}
	for i := 0; i < len(cs); i++ {
		e, ri, id := cs[i], rs[i], -1
		t1 := reflect.TypeOf(e)
		rr := func(b bool) bool {
			id++
			for id < len(ri) && ri[id] == ' ' {
				id++
			}
			if id < len(ri) {
				return ri[id] == '1'
			}
			return b
		}
		for j := 0; j <= i; j++ {
			r := rr(i == j)
			a := cs[j]
			t2 := reflect.TypeOf(a)
			c := convertible(t1, t2)
			Equal(t, r, c, "i=%v, j=%v\n%T\t%[3]v\n%T\t%[4]v", i, j, e, a)
			if t1 != nil && t2 != nil {
				if t1.ConvertibleTo(t2) {
					True(t, c, "i=%v, j=%v\n%T\t%[3]v\n%T\t%[4]v", i, j, e, a)
				}
				if t2.ConvertibleTo(t1) {
					True(t, c, "i=%v, j=%v\n%T\t%[3]v\n%T\t%[4]v", i, j, e, a)
				}
			}
		}
	}
}
